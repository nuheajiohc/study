# 생일 쿠폰 배치 처리 성능 개선 과정

기존 잉크 브릿지 프로젝트에서 생일 쿠폰을 배치로 발급하는 기능을 팀원분이 담당하셔서 개발하셨다.  
배치는 스프링 배치로 처리하였다.  

요구사항은 다음과 같았다.

- 사용자가 생일인 달 1일 00:00 에 생일 쿠폰 제공
  - ex. {5월 1일, 5월 5일, 5월 20일} 생일자 : 5월 1일에 쿠폰 제공
  - 쿠폰 사용 기간 : 5월 1일 ~ 5월 31일

개발된 코드를 보고 개선할 부분이 보여서 리팩토링을 시작했다.

## 기존 구조 문제점

기존 생일 쿠폰 발급 배치는 Spring Batch의 `JpaPagingItemReader`와 `ItemWriter`조합으로 구현되어 있었다.  
구체적인 구조는 다음과 같다.

``` java
// jpa를 활용해서 member 조회
public JpaPagingItemReader<Member> memberLoad() {
    return new JpaPagingItemReaderBuilder<Member>()
        .name("memberLoad")
        .entityManagerFactory(entityManagerFactory)
        .pageSize(chunkSize)
        .queryString("SELECT m FROM Member m WHERE MONTH(m.birthday) = MONTH(:today)")
        .parameterValues(Collections.singletonMap("today", LocalDate.now()))
        .build();
}

// processor는 생략. 

// jpa를 활용해서 memberCoupon 저장
public ItemWriter<MemberCoupon> birthdayCouponWriter() {
    return memberCoupons -> {
        for (MemberCoupon memberCoupon : memberCoupons) {
            entityManager.persist(memberCoupon);
        }
    };
}
```

이 구조는 기능적으로는 문제없이 작동하지만, 대용량 데이터를 처리하기에는 다음과 같은 한계가 있다.

### 1. JPA를 사용할 이유가 없다.
- 위 배치 로직에서는 단순히 회원정보를 읽고 쿠폰을 저장하는 수준에 불과하기 떄문에, JPA가 제공하는 더티 체킹, 1차 캐시, 지연 로딩 등은 오히려 메모리 낭비를 발생시킨다.  
- `member_id`와 `coupon_id`만으로도 로직을 처리할 수 있지만, Entity 기반 설계로 인해 불필요한 모든 칼럼을 조회하게 된다.
- 배치 서버와 메인 서비스가 분리되어 있기 때문에 위의 이유들을 감수하고서 JPA를 사용할 필요는 없다.

### 2. 인덱스를 활용할 수 없는 조건절
- `WHERE MONTH(m.birthday) = MONTH(:today)`는 칼럼에 함수가 적용된 형태이므로 인덱스를 타지 못해서 **Full Table Scan**이 발생한다.

### 3. `SELECT *` 절 사용
- `SELECT m FROM Member m`은 모든 칼럼을 조회하는 쿼리로, I/O 및 네트워크 비용이 커진다.
- 단순히 id 값들만 필요한 상황에서는 `SELECT m.id FROM Member m WHERE ...`처럼 필요한 칼럼만 명시적으로 조회하는 것이 성능을 개선시킨다.

### 4. 너무 작은 Chunk Size 적용
- chunk Size가 10으로 설정되어 있었고, 실제 테스트 결과 200만 명 중 약 16만 명만 처리하는 데에도 3시간 이상 소요되었다.   
  이것도 DB 인덱스 튜닝을 하고 진행한 것이라서 기존 구조로 진행했다면 더 느렸을 것이다.
- 적은 chunk로 인해 I/O 횟수의 증가와 트랜잭션 오버헤드가 주요 원인인 것 같다.

### 5. offset 페이지네이션의 한계
- `JpaPagingItemReader`는 내부적으로 offset 기반 페이지네이션 전략을 사용한다.
- 이 방식은 페이지가 뒤로 갈수록 `OFFSET n`으로 스킵하는 비용이 증가하게 된다.
- 즉, 200만 건 중 후반부 데이터를 읽을 때는 거의 모든 데이터를 건너뛰어야 하므로, 조회 성능이 급격히 저하된다.

### 6. Auto-Increment 환경에서 JPA Bulk Insert 한계
- Auto-Increment 값은 DB가 직접 생성하기 때문에 애플리케이션 환경에서 미리 알 수 없다.   
  그래서 insert가 발생한 후 Entity의 ID값을 채우기 위해 SELECT 쿼리가 발생한다. 이로 인해 insert를 한 건씩 처리할 수 밖에 없는 구조가 된다.
- 기존 방식의 Writer는 Auto-Increment + JPA 구조를 사용하기 때문에 Batch Insert를 한 것과 성능이 확연하게 차이난다. 


## 개선 과정
