

![데드락걸리는 테이블구조.png](img/limited-coupon/%EB%8D%B0%EB%93%9C%EB%9D%BD%EA%B1%B8%EB%A6%AC%EB%8A%94%20%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B5%AC%EC%A1%B0.png)  

약식으로 테이블 구조를 만들어보았다. 간단하게 생각하면 위와 같이 테이블을 관계를 만들 수 있다.  
쿠폰을 만들어두고 발급을 하면 user_coupons에 레코드가 추가된다.  
하지만 이 구조에서는 데드락이 걸리는 문제가 있다.  

```sql

-- transaction A
BEGIN;  -- 1
INSERT INTO user_coupons(coupon_id, member_id) VALUES (1,1); -- 3
UPDATE coupons SET remaining_quantity = remaining_quantity - 1 WHERE coupon_id = 1;  -- 5
COMMIT;

-- transaction B
BEGIN;  -- 2
INSERT INTO user_coupons(coupon_id, member_id) VALUES (1,2);  -- 4
UPDATE coupons SET remaining_quantity = remaining_quantity - 1 WHERE coupon_id = 1;  -- 6
COMMIT;
```
번호 순서대로 실행을 할 때 5번에서 락이 걸리고, 6번에서 아래와 같은 데드락 문구가 나온다.  

예상대로라면 5번이 실행되고, 6번이 실행될 때 transaction A의 트랜잭션이 커밋이나 롤백이 될 때까지 락이 걸려야할 것 같은데 예상과 다른 결과가 나왔다.

![데드락 문구.png](img/limited-coupon/%EB%8D%B0%EB%93%9C%EB%9D%BD%20%EB%AC%B8%EA%B5%AC.png)


그 이유은 [MySQL 공식문서](https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html)에서 확인할 수 있다.  
언급 부분은 아래와 같다.
> If a FOREIGN KEY constraint is defined on a table, any insert, update, or delete 
> that requires the constraint condition to be checked sets shared record-level locks on the records 
> that it looks at to check the constraint.
> InnoDB also sets these locks in the case where the constraint fails.

쉽게 설명하자면 FOREIGN KEY 제약이 정의된 테이블에서 INSERT, UPDATE, DELETE가 수행될 경우, InnoDB는 부모 테이블의 검사 대상이 되는 레코드에 공유 락(즉 S-락) 을 건다.
또한, 제약 조건이 실패하는 경우에도 이 락을 건다.

다시 돌아와서 차례대로 다시 실행 시뮬레이션을 돌려보자  
3번이 실행될 때 coupons 테이블에 대한 FOREIGN KEY 제약 조건이 있는 user_coupons를 삽입하므로 coupons 테이블의 대상 쿠폰에 공유락이 걸린다.  
4번이 실행될 때도 마찬가지로 coupons 테이블의 대상 쿠폰에 공유락이 걸린다.  
공유락은 여러 트랜잭션이 걸 수 있으므로 여기까지는 대기를 할 필요가 없다.
하지만 공유락은 같은 공유락을 허용하지만, 베타락은 허용하지 않아서 대기 해야한다.
여기서 문제가 발생하는데 5번이 실행될 때 대상 레코드에 공유락이 걸려있기 때문에 대기를 하게 된다.  
그 다음 6번에서는 데드락이 발생한다. 왜냐하면 A와 B 트랜잭션은 각각 같은 레코드에 공유락을 갖고 있으면서 해당 레코드에 베타락을 걸고 싶어한다.  
즉, 각 트랜잭션이 각자의 자원을 점유한 채로 서로의 자원을 원하는 상황이 발생해서 데드락이 발생한다.

그렇다면 INSERT와 UPDATE 쿼리 순서를 바꿔 볼까?

```sql

-- transaction A
BEGIN;  -- 1
UPDATE coupons SET remaining_quantity = remaining_quantity - 1 WHERE coupon_id = 1;  -- 3
INSERT INTO user_coupons(coupon_id, member_id) VALUES (1,1); -- 5
COMMIT;

-- transaction B
BEGIN;  -- 2
UPDATE coupons SET remaining_quantity = remaining_quantity - 1 WHERE coupon_id = 1;  -- 4
INSERT INTO user_coupons(coupon_id, member_id) VALUES (1,2);  -- 6
COMMIT;
```

이 경우에는 락은 걸리지만 데드락은 발생하지 않는다. 시뮬레이션해보자.  
3번에서 수량을 줄이기 위해 coupons 테이블의 대상 레코드에 베타락을 건다.  
4번에서도 베타락을 걸고 싶어하지만 베타락은 같은 레코드에 대해 하나만 걸 수 있어서 대기 상태로 남는다.  
5번은 어느 쿼리에도 영향을 받지 않기 때문에 정상적으로 저장된다.  
6번은 4번에서 대기를 하고 있기 때문에 4번 이후에 실행 되도록 기다리게 된다.
그 후 A 트랜잭션이 커밋이나 롤백을 하게 되면 B 트랜잭션 작업이 완료된다.  

그렇다면 이 순서로 코드를 작성하면 데드락이 걸리지 않는걸까?  
그렇지 않다. 이 부분에 관해서는 전에 마주했던 문제여서 이번에는 실제로 시도하지는 않았지만, 설명을 위해 예시 코드를 만들어서 진행하겠다. 
일단 위 방식대로 코드를 대략적으로 작성해보겠다.

```java
@Transactional
public void issueCoupon(Long userid, Long couponId){
    CouponEntity coupon = couponRepository
        .findLimitedCouponByCouponId(couponId)
        .orElseThrow(() -> new BusinessException(ErrorMessage.COUPON_NOT_EXISTS));
    
    coupon.decreaseQuantity();
    userCouponRepository.save(new UserCouponEntity(userId, couponId));
}
```
이런 느낌으로 쿠폰을 조회하고 수량을 줄이고 멤버쿠폰테이블에 발급정보를 저장한다.  
그런데 실제로 실행은 save가 먼저 되고 update 가 진행된다. 
hibernate의 AbstractFlushingEventListener 추상클래스의 performExecutions 메서드를 보면 알 수 있는데 여기에 있는 주석은 다음과 같다.

Execute all SQL (and second-level cache updates) in a special order so that foreign-key constraints cannot be violated:
1. Inserts, in the order they were performed  
2. Updates
3. Deletion of collection elements
4. Insertion of collection elements
5. Deletes, in the order they were performed

그래서 코드 로직 순서를 어떻게 정하든 insert가 먼저 발생하고, update문이 실행되므로 데드락이 발생할 수 밖에 없다.  
물론 로직 순서를 정의한대로 실행시키고 싶으면 flush와 함께 사용하면 된다. flush를 넣는게 좀 그렇다면 연관관계 매핑을 해제하면 된다.  
실무에서는 연관관계 매핑을 안 맺는 경우가 많다고 하지만 나는 아직 학습하는 단계이고 무작정 매핑을 제거하기 보다는 다른 해결책이 있을 것 같아서 해제하지 않았다.  

그렇다면 어떻게 해결할 수 있을까?
지금 나의 경우에는 선착순 쿠폰 뿐만 아니라 수량 제한 없는 쿠폰 발급도 할 수 있다.  
수량 제한이 없다면 수량관련 칼럼이 필요가 없을 것 같다. 그래서 1대1 관계로 수량 테이블을 분리했다.  
선착순 쿠폰은 쿠폰 수량 테이블의 레코드를 가지지만 수량 제한 없는 쿠폰은 레코드를 가지지 않는다.
테이블 구조는 아래와 같다.

![수정된 테이블 구조.png](img/limited-coupon/%EC%88%98%EC%A0%95%EB%90%9C%20%ED%85%8C%EC%9D%B4%EB%B8%94%20%EA%B5%AC%EC%A1%B0.png)

이렇게 구성할경우 member_coupon 테이블에 insert를 한다면 coupon 테이블의 대상 레코드는 공유락이 걸린다.
하지만 쿠폰 수량 테이블에는 영향을 미치지 않기 때문에 데드락에 걸리지 않고 수량감소가 가능하다.
(물론 수량을 줄이는 두 트랜잭션은 베타락에 의해 대기하는 과정이 필요하긴 한다.)
쿠폰수량을 먼저 감소시켜도 데드락에는 자유롭다.  

그래서 테이블 구조는 구성하였다.

이제 데드락은 해결되었고, 코드 단위에서 동시성을 해결해 나가는 과정에 대해서 이야기해보겠다.
![V1코드구조.png](img/limited-coupon/V1%EC%BD%94%EB%93%9C%EA%B5%AC%EC%A1%B0.png)

선착순 쿠폰을 조회하고, 쿠폰 수량을 줄인다. 그 후 중복 발급 여부를 판단하고, 쿠폰수량을 데이터베이스에 저장한다.  
그리고 멤버쿠폰 테이블에 쿠폰을 추가한다.

![순차발급.png](img/limited-coupon/%EC%88%9C%EC%B0%A8%EB%B0%9C%EA%B8%89.png)

id가 3번인 쿠폰이 선착순 쿠폰이고, 10개의 쿠폰만 발급가능하다.
여기서 100명의 회원이 쿠폰을 순차적으로 요청할 경우 10개의 쿠폰이 발급되어야하고, 90개의 쿠폰 발급 실패가 발생할 것으로 가정했다.

![순차발급출력.png](img/limited-coupon/%EC%88%9C%EC%B0%A8%EB%B0%9C%EA%B8%89%EC%B6%9C%EB%A0%A5.png)

그 결과 예상한 수량인 10장만 발급되어 테스트에 성공했다.

하지만 실제 상황에서는 이런 순차상황보다는 동시 요청 상황이 발생할 수 있고, 선착순 쿠폰 요청 특성상 거의 무조건 동시 요청이 발생한다.
그래서 동일상황에서 동시에 여러 요청이 발생하는 상황을 테스트 해보았다.


기존 코드와 큰 틀은 같지만, 쓰레드를 100개 만들어서 동시에 발급 요청을 진행했다.

![동시성문제발급테스트코드.png](img/limited-coupon/%EB%8F%99%EC%8B%9C%EC%84%B1%EB%AC%B8%EC%A0%9C%EB%B0%9C%EA%B8%89%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C.png)
![동시성 문제 출력.png](img/limited-coupon/%EB%8F%99%EC%8B%9C%EC%84%B1%20%EB%AC%B8%EC%A0%9C%20%EC%B6%9C%EB%A0%A5.png)  
그 결과 같은 조건에서 쿠폰 발급이 99개나 성공하였다. 재시도를 할 때는 100개 전부 성공할 때도 있고 조금씩 다르지만 동시성 문제가 생긴다는 사실은 변함없다.


그렇다면 이번에는 동시성 문제를 해결해보도록 하자.

가장 쉽게 접할 수 있는 동시성 해결 방법인 synchronized를 적용해보자.

java에서 synchronized 키워드를 붙이면 대상 메서드에 접근할 때 락을 걸어서 멀티 스레드 환경에서 동시성을 제어할 수 있다.

위에서 소개한 코드와 같은데 synchronized 키워드만 추가하였다.

![synchronized 붙인 코드.png](img/limited-coupon/synchronized%20%EB%B6%99%EC%9D%B8%20%EC%BD%94%EB%93%9C.png)

결과를 확인해보자.

![synchronized 결과출력.png](img/limited-coupon/synchronized%20%EA%B2%B0%EA%B3%BC%EC%B6%9C%EB%A0%A5.png)

정상적인 경우였다면 쿠폰은 10개가 출력되었어야 하지만 예상과 다르게 12개가 출력되었다. 여러 번 시도한 결과 전부 쿠폰 발급 정합성은 맞추지 못하였다.  
하지만 완벽히는 아니지만 어느정도 동시성 제어가 되었다. 

왜 그런 것일까?
정답은 @Transactional 키워드에 있다. @Transactional 키워드와 synchronized 키우드를 같이 사용하게 되면 문제가 생긴다.

왜냐하면 @Transactinoal 키워드를 사용하게 되면 Spring은 프록시 객체를 생성하게 된다.  
@Transactional 키워드를 붙인다고 갑자기 뚝딱 트랜잭션이 적용되는 것이 아니라 내부적으로는 해당 메서드를 호출하는 프록시 객체를 만들게 된다.

예를 들어 간단하게 코드로 설명하자면 아래와 같다.
프록시 객체가 만들어질 때 원본 메서드를 트랜잭션 로직이 감싼채로 실행된다.  
자세한 내용은 [JPA save와 saveAll 비교(feat. @Transactional의 영향) - 5. 분석](https://nuheajiohc.tistory.com/53) 에서 설명해두었다.  

``` java
public class CouponService$$EnhancerBySpringCGLIB {
    
    private CouponService couponService;
    
    public issueLimitCouponV1(Long userId, Long couponId) {
        tx.start();
        couponService.issueLimitCouponV1(userId, couponId);
        tx.end();
    }
}
```

이렇게 되면 두개의 쓰레드가 동시에 접근하게 되면 트랜잭션을 동시에 시작할 수 있다.  
하지만 원본 메서드에는 synchronized 키워드가 있기 때문에 여기서 둘 중 하나의 스레드는 진입하게 되고 나머지 하나는 대기를 하게 된다.  
쿠폰 수량이 10인 상태에서 하나의 스레드가 먼저 들어가서 수량을 줄이고 로직을 끝내고 메서드를 나오면 다른 스레드가 접근할 수 있게 되는데 대기하던 스레드는 이미 트랜잭션이 시작한 상태이기 때문에 수량을 줄이기 이전의 레코드에 접근하게 된다.  
그래서 아 때도 수량이 10이다. 이런 현상 떄문에 동시성 문제가 해결되지 않은 것이다.  
다만 원본 메서드에 접근할 때는 락이 걸리기 때문에 아예 사용하지 않은 것보다는 동시성 문제가 비교적 해결 된 것이다.  
하지만 이 방식으로는 동시성 문제를 해결할 수 없기 때문에 다른 방식을 찾아야 한다.

@Transactinal 키워드 때문에 생긴 문제이기 때문에 @Transactional을 제거하면 동시성 문제가 해결된다.  
하지만 트랜잭션이 없는 상황에서는 변경감지가 되지 않고, 전체 작업을 하나로 묶을 수 없어서 올바른 해결책이라고 볼 수 없다.

@Transactional와 synchronized 키워드를 같이 사용하면 synchronized 밖에서 트랜잭션이 생긴다는 것은 아까 확인했다.  
그렇다면 @Transactional 애노테이션을 감싸는 메서드에서 synchronized를 사용한다면 락을 잡은채로 메서드에 진입해서 프록시 객체가 생기므로 동시성 문제를 의도한대로 잡을 수 있을 것 같다.  

코드로 나타내면 아래와 같고 이 서비스 컨트롤러에서 호출해보자
```java
@Service
@RequiredArgsConstructor
public class SynchronizedService {

    private final CouponService couponService;

    public synchronized void issueCoupon(Long userId, Long couponId) {
        couponService.issueLimitCouponV1(userId, couponId);
    }
}
```

![올바른 synchronized 출력.png](img/limited-coupon/%EC%98%AC%EB%B0%94%EB%A5%B8%20synchronized%20%EC%B6%9C%EB%A0%A5.png)

결과는 정상적으로 동시성 문제가 해결되었다.  

하지만 이것을 사용하기에는 몇가지 문제가 있다.  
먼저 위의 예시처럼 원래 서비스와 컨트롤러 사이에 새로운 클래스가 필요해서 이전에 비해 비교적 가독성이 떨어진다.  
두번째는 우리 프로젝트가 기존에는 서버를 다중 인스턴스로 이루어져 있었다.  
synchronized 키워드는 각 서버안으로 들어오는 요청에 대해서는 동시성 문제를 해결할 수 있지만, 서로 다른 서버로 들어오는 요청에 대해서는 동시성을 해결할 수 없다.  
마지막으로 선착순 쿠폰이라서 들어오는 순서를 잘 지켜서 쿠폰 발급을 진행해야하는데 synchronized 키워드로 동시성 문제를 해결할 경우 공정성이 어긋난다.  
즉 A,B,C의 사람이 순서대로 요청을 보낸상황에서 A의 처리가 끝난 후 B가 자원을 획득해야하는데 기다리고 있는 요청 중 무작위로 자원을 넘겨주게 된다. 그래서 C가 자원을 획득할 수 있다.  
이러한 이유들로 인해 synchronized 키워드로 동시성 문제를 해결하기는 힘들 것으로 판단했다.  


자바 애플리케이션에서 동시성 문제를 해결하는 방법은 하나 더 있는데 그것은 reentrantLock 클래스이다.
이것은 synchronized 키워드와 달리 객체로 제공되는 락이고, 공정성을 부여해줄 수 있다.
ReentrantLock에 true 매개변수를 추가하면 공정성을 부여할 수 있다.
```java
@Service
@RequiredArgsConstructor
public class ReentrantLockService {

    private final CouponService couponService;
    private ReentrantLock reentrantLock = new ReentrantLock(true);

    public void issueCoupon(Long userId, Long couponId) {
        reentrantLock.lock();
        try {
            couponService.issueLimitCouponV1(userId, couponId);
        } finally {
            reentrantLock.unlock();
        }
    }
}
```
하지만 공정성의 문제가 해결될 뿐 다중 서버에서의 동시성 문제와 중간계층의 필요성은 synchronized로 해결한 것과 같으므로 이 방식도 패스하겠다.  


그럼 다중 서버에서 동시성 문제를 잡기 위해서는 다른 방향으로 생각해보아야 한다.  
애플리케이션 내에서는 다른 서버에 영향을 주지 못하기 때문에 공동으로 사용하는 데이터베이스를 생각해볼 수 있다.  
여기에서는 크게 낙관적 락과 비관적 락이 존재한다.

낙관적 락부터 적용해보자.






조회를 수량 감소이후로 돌린다면 정합성을 지킬수있다.
하지만 데이터 조작이 일어나고 롤백이 무조건 발생하기 떄문에 좋은 구조는 아니다.

이렇게 하는건 어떤가?
조회 0 인가? -> 수량감소 로직 실행안하기 위함
수량 감소
조회 0 인가? -> 완벽한 정합성을 위함



테이블 구조 변경을 통한 데드락 해결

